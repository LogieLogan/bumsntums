// lib/features/workout_planning/services/ai_planning_service.dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';
import '../models/scheduled_workout.dart';
import '../models/workout_plan.dart';
import '../repositories/workout_planning_repository.dart';
import '../../../features/workouts/models/workout.dart';
import '../../../features/workouts/services/workout_service.dart';
import '../../../features/ai/services/openai_service.dart';
import '../../../shared/analytics/firebase_analytics_service.dart';

class AIPlanningService {
  final WorkoutPlanningRepository _planningRepository;
  final WorkoutService _workoutService;
  final OpenAIService _aiService;
  final AnalyticsService _analytics;
  final _uuid = const Uuid();

  AIPlanningService({
    required WorkoutPlanningRepository planningRepository,
    required WorkoutService workoutService,
    required OpenAIService aiService,
    required AnalyticsService analytics,
  })  : _planningRepository = planningRepository,
        _workoutService = workoutService,
        _aiService = aiService,
        _analytics = analytics;

  // Generate an AI workout plan based on user preferences
  Future<WorkoutPlan> generateWorkoutPlan({
    required String userId,
    required DateTime startDate,
    required DateTime endDate,
    required int daysPerWeek,
    required List<String> focusAreas,
    required String fitnessLevel,
    String? planName,
  }) async {
    try {
      _analytics.logEvent(
        name: 'generate_ai_workout_plan',
        parameters: {
          'userId': userId,
          'daysPerWeek': daysPerWeek,
          'focusAreas': focusAreas.join(','),
          'fitnessLevel': fitnessLevel,
        },
      );

      // Create empty plan first
      final plan = await _planningRepository.createWorkoutPlan(
        userId,
        planName ?? 'AI Workout Plan',
        startDate,
        endDate,
        description: 'Generated by AI based on your goals and preferences',
      );

      // Get suitable workouts
      List<Workout> workouts = [];
      
      // Convert string categories to enum values
      for (final area in focusAreas) {
        WorkoutCategory? category;
        
        switch (area.toLowerCase()) {
          case 'bums':
            category = WorkoutCategory.bums;
            break;
          case 'tums':
            category = WorkoutCategory.tums;
            break;
          case 'full body':
            category = WorkoutCategory.fullBody;
            break;
          case 'cardio':
            category = WorkoutCategory.cardio;
            break;
          case 'quick':
          case 'arms':
          case 'legs':
          case 'core':
            // Skip for now, or implement if you have these categories
            continue;
        }
        
        if (category != null) {
          // Use your existing methods to get workouts
          try {
            final categoryWorkouts = await _workoutService.getWorkoutsByCategory(category);
            
            // Filter by difficulty
            WorkoutDifficulty difficulty;
            switch (fitnessLevel.toLowerCase()) {
              case 'intermediate':
                difficulty = WorkoutDifficulty.intermediate;
                break;
              case 'advanced':
                difficulty = WorkoutDifficulty.advanced;
                break;
              case 'beginner':
              default:
                difficulty = WorkoutDifficulty.beginner;
                break;
            }
            
            final filteredWorkouts = categoryWorkouts.where(
              (w) => w.difficulty == difficulty
            ).toList();
            
            workouts.addAll(filteredWorkouts);
          } catch (e) {
            print('Error getting workouts for $area: $e');
          }
        }
      }

      if (workouts.isEmpty) {
        // Fallback - get any workouts if no category matches
        try {
          workouts = await _workoutService.getAllWorkouts();
        } catch (e) {
          throw Exception('No suitable workouts found: $e');
        }
      }

      // Use AI to create a balanced workout schedule
      final schedule = await _createWorkoutSchedule(
        userId,
        plan.id,
        startDate,
        endDate,
        daysPerWeek,
        workouts,
      );
      
      // Calculate workout distribution analytics
      final targetAreaDistribution = _calculateTargetAreaDistribution(schedule);
      
      // Update the plan with the AI metadata
      final updatedPlan = plan.copyWith(
        scheduledWorkouts: schedule,
        targetAreaDistribution: targetAreaDistribution,
      );

      return updatedPlan;
    } catch (e) {
      _analytics.logError(error: 'Error generating AI workout plan: $e');
      throw e;
    }
  }

  // Create a workout schedule with optimal training days
  Future<List<ScheduledWorkout>> _createWorkoutSchedule(
    String userId,
    String planId,
    DateTime startDate,
    DateTime endDate,
    int daysPerWeek,
    List<Workout> availableWorkouts,
  ) async {
    final scheduledWorkouts = <ScheduledWorkout>[];
    
    // Determine optimal training days
    List<int> trainingDays = _determineOptimalDays(daysPerWeek);
    
    // Get all dates between start and end
    int totalDays = endDate.difference(startDate).inDays + 1;
    List<DateTime> allDates = [];
    
    for (int i = 0; i < totalDays; i++) {
      allDates.add(startDate.add(Duration(days: i)));
    }
    
    // Filter dates to include only training days
    List<DateTime> trainingDates = allDates
        .where((date) => trainingDays.contains(date.weekday))
        .toList();
    
    // Create a balanced workout selection
    final balancedWorkouts = _createBalancedSelection(
      availableWorkouts, 
      trainingDates.length
    );
    
    // Schedule each workout
    for (int i = 0; i < trainingDates.length && i < balancedWorkouts.length; i++) {
      try {
        final scheduledWorkout = await _planningRepository.scheduleWorkout(
          planId,
          balancedWorkouts[i].id,
          userId,
          trainingDates[i],
        );
        
        scheduledWorkouts.add(scheduledWorkout);
      } catch (e) {
        print('Error scheduling workout: $e');
      }
    }
    
    return scheduledWorkouts;
  }
  
  // Create a balanced workout selection
  List<Workout> _createBalancedSelection(
    List<Workout> workouts, 
    int count
  ) {
    if (workouts.isEmpty) {
      return [];
    }
    
    // Group workouts by category
    final byCategory = <WorkoutCategory, List<Workout>>{};
    
    for (final workout in workouts) {
      if (!byCategory.containsKey(workout.category)) {
        byCategory[workout.category] = [];
      }
      byCategory[workout.category]!.add(workout);
    }
    
    // Create a balanced selection
    final result = <Workout>[];
    final categories = byCategory.keys.toList();
    
    // Ensure we don't exceed available workouts
    final targetCount = count > workouts.length ? workouts.length : count;
    
    while (result.length < targetCount) {
      for (final category in categories) {
        if (byCategory[category]!.isNotEmpty && result.length < targetCount) {
          // Take workouts from each category in rotation
          result.add(byCategory[category]!.first);
          
          // Move this workout to the end for variety
          final workout = byCategory[category]!.removeAt(0);
          byCategory[category]!.add(workout);
        }
      }
    }
    
    return result;
  }
  
  // Determine optimal training days based on days per week
  List<int> _determineOptimalDays(int daysPerWeek) {
    switch (daysPerWeek) {
      case 1:
        return [1]; // Monday
      case 2:
        return [1, 4]; // Monday, Thursday
      case 3:
        return [1, 3, 5]; // Monday, Wednesday, Friday
      case 4:
        return [1, 3, 5, 7]; // Monday, Wednesday, Friday, Sunday
      case 5:
        return [1, 2, 4, 5, 7]; // Monday, Tuesday, Thursday, Friday, Sunday
      case 6:
        return [1, 2, 3, 5, 6, 7]; // All days except Thursday
      case 7:
        return [1, 2, 3, 4, 5, 6, 7]; // All days
      default:
        return [1, 3, 5]; // Default to 3 days (M, W, F)
    }
  }
  
  // Calculate target area distribution based on scheduled workouts
  Map<String, double> _calculateTargetAreaDistribution(
    List<ScheduledWorkout> scheduledWorkouts,
  ) {
    final distribution = <String, double>{};
    
    for (final scheduledWorkout in scheduledWorkouts) {
      final workout = scheduledWorkout.workout;
      if (workout != null) {
        // Count by category
        final category = workout.category.name;
        distribution[category] = (distribution[category] ?? 0) + 1;
      }
    }
    
    // Convert to percentages
    final total = distribution.values.fold<double>(0, (sum, value) => sum + value);
    if (total > 0) {
      distribution.forEach((key, value) {
        distribution[key] = (value / total) * 100;
      });
    }
    
    return distribution;
  }
}